### Слайд 1: Дизайн приложения

**Заголовок:** Дизайн и пользовательский интерфейс

**(На слайде разместить 4 скриншота: список маршрутов, окно фильтров, создание маршрута - общая информация, создание маршрута - добавление точек)**

**Текст:**
Приложение "Путешествия по России" спроектировано с акцентом на простоту и удобство использования.

*   **Экран списка маршрутов:** Представляет собой ленту доступных маршрутов с кратким описанием, изображением и основными характеристиками (сложность, дистанция). Реализована возможность прокрутки и быстрого просмотра.
*   **Модальное окно фильтров:** Вызывается с экрана списка маршрутов и позволяет пользователю гибко настроить параметры поиска: выбрать диапазон сложности, дистанции, тип передвижения и тематику маршрута. Фильтры применяются немедленно к списку.
*   **Экран создания маршрута (Шаг 1: Общая информация):** Первый этап создания собственного маршрута. Пользователь вводит название, подробное описание, выбирает тип транспорта, тематику, уровень сложности и указывает общую протяженность. Форма содержит валидацию для обязательных полей.
*   **Экран создания маршрута (Шаг 2: Добавление точек):** Второй этап, где пользователь добавляет точки маршрута на карте. Можно добавлять как "места" (с фото и описанием), так и "опорные точки". Реализована возможность изменять порядок точек перетаскиванием и редактировать каждую точку отдельно.

Интерфейс выполнен в светлых тонах, с использованием интуитивно понятных иконок и элементов управления, чтобы обеспечить комфортное взаимодействие для всех категорий пользователей.

---

### Слайд 2: Подход Feature-First

**Заголовок:** Организация кода: Feature-First

**(На слайде разместить Mermaid-диаграмму `graph TD` из запроса)**

**Текст:**
Для организации кодовой базы приложения был выбран подход Feature-First. Этот подход предполагает деление приложения не по техническим слоям (UI, Domain, Data), а по функциональным возможностям (фичам).

*   **Структура:** Каждая фича представляет собой отдельный модуль (директорию) со своей собственной внутренней структурой, включающей UI, логику (BLoC), доменные модели и, при необходимости, слой данных.
*   **Преимущества:**
    *   **Модульность:** Фичи относительно независимы, что упрощает их разработку, тестирование и поддержку.
    *   **Масштабируемость:** Легко добавлять новые фичи, не затрагивая существующие.
    *   **Командная работа:** Разные команды или разработчики могут параллельно работать над разными фичами.
    *   **Понятность:** Структура проекта отражает функционал приложения, что облегчает навигацию по коду.
*   **Пример (Фича "Контент"):** Как видно на схеме, основная фича "Контент" содержит подфичи: "Создание маршрута", "Список маршрутов", "Детали маршрута". Каждая из них имеет свою внутреннюю структуру. Общий код (модели данных, DI-контейнеры, общие виджеты) вынесен в директорию `shared` внутри фичи "Контент".

Такой подход позволил создать хорошо структурированное и легко поддерживаемое приложение.

---

### Слайд 3: Выбор архитектуры BLoC

**Заголовок:** Управление состоянием: Архитектура BLoC

**Текст:**
Для управления состоянием пользовательского интерфейса и бизнес-логикой был выбран архитектурный паттерн BLoC (Business Logic Component).

*   **Причины выбора:**
    *   **Реактивность:** BLoC основан на потоках (Streams), что позволяет UI автоматически реагировать на изменения состояния.
    *   **Разделение ответственности (SoC):** Четко отделяет UI от бизнес-логики, что повышает чистоту и тестируемость кода. UI отправляет события (Events) в BLoC, а BLoC возвращает состояния (States), на которые UI подписывается.
    *   **Тестируемость:** Бизнес-логику в BLoC легко тестировать изолированно от UI.
    *   **Масштабируемость:** Подходит для сложных приложений с множеством экранов и состояний.
    *   **Предсказуемость:** Поток данных однонаправленный (UI -> Event -> BLoC -> State -> UI), что делает поведение приложения более предсказуемым.
*   **Использование:** В приложении каждый сложный экран или функциональный модуль имеет свой BLoC (или Cubit – упрощенную версию BLoC) для управления своим состоянием. BLoC'и взаимодействуют со слоем данных (репозиториями) для получения или отправки информации.

Выбор BLoC обеспечил создание структурированного, тестируемого и масштабируемого приложения с предсказуемым потоком данных.

---

### Слайд 4: Реализация BLoC: Получение и фильтрация маршрутов

**Заголовок:** BLoC в действии: Фильтрация и загрузка маршрутов

**(На слайде разместить Mermaid-диаграмму `sequenceDiagram` для фильтрации)**

**Текст:**
Рассмотрим взаимодействие BLoC'ов на примере фильтрации и отображения списка маршрутов. В этом процессе участвуют два основных компонента: `FilterRoutesBloc` и `RoutesBloc`, а также UI (`ContentPage`).

*   **Шаг 1: Пользователь применяет фильтры:** Пользователь взаимодействует с UI (например, в модальном окне фильтров) и выбирает нужные параметры.
*   **Шаг 2: Обновление состояния фильтров:** UI отправляет событие `UserFilterRoutesChanged` с новыми параметрами в `FilterRoutesBloc`.
*   **Шаг 3: `FilterRoutesBloc` обновляет состояние:** Блок обрабатывает событие и эмитит новое состояние `FilterRoutesLoadSuccess`, содержащее как доступные параметры фильтрации, так и *новые выбранные пользователем* параметры.
*   **Шаг 4: UI реагирует на изменение фильтров:** `BlocListener` в `ContentPage` отслеживает изменения в состоянии `FilterRoutesBloc`. Когда он обнаруживает, что `userFilterRoutesParams` изменились, он инициирует загрузку новых данных.
*   **Шаг 5: Запрос на получение маршрутов:** `BlocListener` отправляет событие `RoutesFetched` в `RoutesBloc`, передавая ему актуальные параметры фильтрации из состояния `FilterRoutesBloc`.
*   **Шаг 6: `RoutesBloc` загружает данные:** `RoutesBloc` получает событие, переходит в состояние загрузки, обращается к репозиторию (`_contentRepository.getRouteModels`) с переданными параметрами фильтрации и получает список маршрутов.
*   **Шаг 7: Отображение результата:** `RoutesBloc` эмитит состояние `RoutesLoadSuccess` с загруженными маршрутами (или `RoutesLoadFailure` в случае ошибки), на которое реагирует UI, отображая обновленный список.

Такое взаимодействие позволяет разделить логику управления фильтрами и логику загрузки данных, обеспечивая четкое и реактивное обновление интерфейса.

---

### Слайд 5: BLoC и Интерактор: Создание маршрута

**Заголовок:** BLoC и Интерактор: Реализация создания маршрута

**(На слайде разместить Mermaid-диаграмму `sequenceDiagram` для создания маршрута)**

**Текст:**
Фича создания маршрута является сложным многошаговым процессом, требующим управления состоянием нескольких форм и координации запросов к бэкенду. Для этого используются несколько BLoC'ов и Интерактор.

*   **`CreateRouteFormBloc`:** Управляет состоянием формы общей информации о маршруте (название, описание, тип и т.д.). Валидирует введенные данные и переходит в состояние `Filled` только когда все обязательные поля заполнены корректно.
*   **`CreatePointFormBloc`:** Управляет состоянием формы для *одной* точки маршрута (места или опорной точки). Отвечает за ввод адреса, координат, описания, добавление/удаление/переупорядочивание фотографий (для мест). Также валидирует данные.
*   **`CreatePointsFormBloc`:** Управляет *списком* точек, добавленных в маршрут. Обрабатывает события добавления новой точки (полученной от `CreatePointFormBloc`), удаления точки и изменения порядка точек (drag-and-drop).
*   **`CreateRouteInteractor`:** Координирует процесс финального создания маршрута.
    1.  Получает финальные состояния от `CreateRouteFormBloc` (общая информация) и `CreatePointsFormBloc` (список точек).
    2.  Итерирует по списку точек:
        *   Для "мест" (`CreatePlacePointFormModel`): вызывает метод репозитория `createPlace` для создания места и загрузки его фотографий, сохраняет полученный `placeId`.
        *   Для "опорных точек" (`CreatePathPointFormModel`): сохраняет их координаты.
    3.  После обработки всех точек вызывает метод репозитория `createRoute`, передавая ему общую информацию о маршруте, список `placeId` созданных мест и список координат опорных точек.

Такая архитектура с использованием нескольких BLoC'ов для разных частей формы и Интерактора для координации позволяет эффективно управлять сложным состоянием и взаимодействием с бэкендом.

---

### Слайд 6: Базовые концепции yx\_scope

**Заголовок:** Управление зависимостями: yx\_scope - Концепции

**(Можно добавить логотип yx_scope или ссылку на Habr: [https://habr.com/ru/companies/yandex/articles/852278/](https://habr.com/ru/companies/yandex/articles/852278/))**

**Текст:**
Для управления зависимостями (Dependency Injection - DI) в проекте используется фреймворк `yx_scope`, разработанный в Яндексе. Он предоставляет гибкий механизм для работы со скоупами (областями видимости зависимостей).

*   **Основные сущности:**
    *   **Scope (Скоуп):** Контейнер с набором зависимостей, имеющий определенный жизненный цикл. Скоупы могут быть вложенными.
    *   **Dep (Зависимость):** Обертка над конкретным инстансом зависимости внутри скоупа.
    *   **ScopeHolder:** Объект, управляющий жизненным циклом скоупа. Инстансы `ScopeHolder` не статичны, их жизненный цикл привязан к месту их создания (например, к StatefulWidget).
*   **Ключевые особенности:**
    *   **Compile-safety:** Ошибки конфигурации DI (например, циклические зависимости, отсутствующие зависимости) обнаруживаются на этапе компиляции.
    *   **Чистый Dart:** Ядро библиотеки не зависит от Flutter, но легко интегрируется с ним (`yx_scope_flutter`).
    *   **Без кодогенерации:** Не требует запуска генераторов кода для базовой работы.
    *   **Декларативность:** Зависимости и их связи описываются декларативно.
    *   **Управляемый жизненный цикл:** Скоупы проходят через состояния: `none` -> `initializing` (инициализация async-зависимостей) -> `available` -> `disposing` (очистка async-зависимостей) -> `none`.
    *   **Асинхронные зависимости:** Поддерживает зависимости, требующие асинхронной инициализации и очистки (`AsyncLifecycle`).

`yx_scope` позволяет создавать гибкие и безопасные DI-конфигурации, особенно в многомодульных проектах.

---

### Слайд 7: Использование yx\_scope в приложении

**Заголовок:** Управление зависимостями: yx\_scope - Применение

**(Можно показать упрощенную схему иерархии скоупов: AppScope -> ContentScope -> CreateRouteScope)**

**Текст:**
В нашем приложении `yx_scope` используется для организации иерархии зависимостей, соответствующей Feature-First подходу.

*   **Иерархия скоупов:**
    *   **`AppScope` (Глобальный):** Создается при старте приложения и живет все время его работы. Содержит общеприложенческие зависимости:
        *   Клиент gRPC для взаимодействия с бэкендом.
        *   Сервис логирования (`logger`).
        *   Основные репозитории.
        *   Навигация (`go_router`).
    *   **`ContentScope` (Фича Контента):** Дочерний скоуп для `AppScope`. Создается при входе в раздел контента (просмотр/создание маршрутов). Содержит зависимости, специфичные для этой фичи:
        *   Репозиторий контента (`ContentRepository`).
        *   BLoC'и для списка маршрутов и фильтров (`RoutesBloc`, `FilterRoutesBloc`).
        *   Конвертеры моделей данных.
    *   **`CreateRouteScope` (Фича Создания Маршрута):** Дочерний скоуп для `ContentScope`. Создается при переходе на экран создания маршрута и уничтожается при выходе из него. Содержит зависимости, нужные только для создания маршрута:
        *   BLoC'и формы (`CreateRouteFormBloc`, `CreatePointsFormBloc`, `CreatePointFormBloc`).
        *   Интерактор (`CreateRouteInteractor`).
        *   Зависимости для работы с картой и галереей изображений (`ImagePicker`, `YandexMapController`).

*   **Преимущества такого подхода:**
    *   **Управление жизненным циклом:** Зависимости создаются только тогда, когда они нужны (при активации фичи), и уничтожаются при ее завершении, освобождая ресурсы.
    *   **Инкапсуляция:** Зависимости фичи инкапсулированы внутри ее скоупа.
    *   **Согласованность с Feature-First:** Иерархия скоупов отражает иерархию фич.

Использование `yx_scope` позволило эффективно управлять зависимостями и их жизненным циклом в соответствии с архитектурой приложения.

---

### Слайд 8: Blurhash для плейсхолдеров изображений

**Заголовок:** Улучшение UX: Плейсхолдеры Blurhash

**(На слайде разместить код использования `CachedNetworkImage` и `BlurhashFfiImage`)**

**Текст:**
Для улучшения пользовательского опыта при загрузке изображений из сети используется техника Blurhash.

*   **Проблема:** Загрузка изображений, особенно на медленном соединении, может занимать время. Отображение пустого места или стандартного индикатора загрузки выглядит неэстетично.
*   **Решение: Blurhash:** Это алгоритм, который кодирует "превью" изображения в очень короткую строку символов (обычно 20-30 символов). Эта строка хранится вместе с URL основного изображения.
*   **Реализация:**
    1.  Используется библиотека `cached_network_image` для загрузки и кэширования сетевых изображений.
    2.  Библиотека `blurhash_ffi` используется для декодирования строки Blurhash в изображение-плейсхолдер.
    3.  В виджете `CachedNetworkImage` в качестве `placeholder` указывается `BlurhashFfiImage`, которому передается строка Blurhash (`image.placeholder`).
*   **Результат:** Пока загружается основное изображение (`imageUrl`), пользователь видит размытую, но передающую основные цвета и формы версию изображения (`BlurhashFfiImage`). Это создает ощущение более быстрой загрузки и делает интерфейс визуально приятнее.

```dart
CachedNetworkImage(
    imageUrl: image.url, // URL основного изображения
    imageBuilder: (context, imageProvider) => DecoratedBox(
        // ... отображение загруженного изображения
    ),
    fit: BoxFit.cover,
    placeholder: (_, __) => DecoratedBox( // Плейсхолдер
        decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(10),
            image: DecorationImage(
                // Декодируем Blurhash строку в изображение
                image: BlurhashFfiImage(image.placeholder),
                fit: BoxFit.cover,
            ),
        ),
    ),
),
```

---

### Слайд 9: Открытие маршрутов во внешних картах (Диплинки)

**Заголовок:** Интеграция с картами: Диплинки в Яндекс Карты и 2GIS

**(На слайде разместить код генерации URL и вызова `url_launcher`)**

**Текст:**
Приложение предоставляет пользователям возможность открыть построенный маршрут во внешних картографических приложениях, таких как Яндекс Карты и 2GIS, для навигации. Это реализовано с помощью формирования диплинков (специальных URL) и их запуска.

*   **Формирование URL:**
    *   Для каждой модели маршрута (`RouteModel`) реализованы геттеры `yandexMapsUrl` и `doubleGisUrl`.
    *   Эти геттеры формируют URL в соответствии с форматом, ожидаемым Яндекс Картами и 2GIS для построения маршрута по точкам.
    *   Координаты точек извлекаются из модели и форматируются в строку с нужными разделителями (`~` для Яндекса, `|` для 2GIS).
    *   Добавляются необходимые префиксы и параметры (`rtext`, `rtt=pd` для Яндекса; `directions/tab/pedestrian/points/` для 2GIS).

```dart
// Пример для Яндекс Карт
String get yandexMapsUrl {
  final prefix = 'https://yandex.ru/maps/?rtext=';
  final points = places.map((place) => '${place.location.lat.toStringAsFixed(6)},${place.location.lon.toStringAsFixed(6)}').join('~');
  final suffix = '&rtt=pd'; // Пешеходный маршрут
  return '$prefix$points$suffix';
}

// Пример для 2GIS
String get doubleGisUrl {
  final prefix = 'https://2gis.ru/directions/tab/pedestrian/points/';
  final points = places.map((place) => '${place.location.lon.toStringAsFixed(6)},${place.location.lat.toStringAsFixed(6)}').join('|');
  return '$prefix$points';
}
```

*   **Запуск URL:**
    *   Используется стандартная библиотека `url_launcher`.
    *   При нажатии на соответствующую кнопку вызывается функция `launchUrl`, которой передается сформированный URL, преобразованный в `Uri`.
    *   Операционная система автоматически предлагает открыть этот URL в подходящем установленном приложении (Яндекс Карты или 2GIS).

```dart
// Вызов для открытия URL
import 'package:url_launcher/url_launcher.dart' as url_launcher;

Future<void> openMapUrl(String url) async {
  final uri = Uri.parse(url);
  if (await url_launcher.canLaunchUrl(uri)) {
    await url_launcher.launchUrl(uri, mode: LaunchMode.externalApplication);
  } else {
    // Обработка ошибки: не удалось запустить URL
  }
}
```

Эта интеграция позволяет пользователям легко перейти к навигации по выбранному маршруту в привычном им приложении.

---

### Слайд 10: Основные используемые библиотеки

**Заголовок:** Технологический стек: Ключевые библиотеки

**(На слайде разместить Mermaid-диаграмму `mindmap` из запроса)**

**Текст:**
Успешная разработка приложения стала возможна благодаря использованию ряда ключевых библиотек и фреймворков экосистемы Flutter и Dart:

*   **Управление состоянием:** `bloc`, `flutter_bloc`, `hydrated_bloc` для реализации паттерна BLoC и сохранения состояния; `provider` (возможно, для простых случаев или DI).
*   **Взаимодействие с бэкендом:** `grpc` и `protobuf` для эффективного и типизированного обмена данными с сервером по протоколу gRPC.
*   **Навигация:** `go_router` для декларативной и типизированной навигации между экранами и обработки диплинков.
*   **Логирование:** `logger` для записи информационных и отладочных сообщений.
*   **Локализация:** `flutter_localizations` и `intl` для поддержки русского языка и форматирования данных.
*   **Отображение изображений:** `cached_network_image` для загрузки и кэширования, `blurhash_ffi` для плейсхолдеров, `flutter_svg` для векторной графики.
*   **Темы:** `theme_extensions_builder` для создания кастомных расширений темы.
*   **DI:** `yx_scope` и `yx_scope_flutter` для управления зависимостями.
*   **Работа с устройством:** `image_picker` для доступа к галерее/камере, `url_launcher` для открытия внешних ссылок, `path_provider`, `shared_preferences`.
*   **Карты:** `yandex_maps_mapkit_lite` для интеграции Яндекс Карт.
*   **Утилиты:** `equatable`, `copy_with_extension`, `collection`, `rxdart`, `uuid`.

Этот набор инструментов позволил реализовать необходимый функционал, обеспечив при этом хорошую производительность, структурированность кода и удобство разработки.

---
